diff --git a/src/cmd.rs b/src/cmd.rs
index 8a30d6b..4684e80 100644
--- a/src/cmd.rs
+++ b/src/cmd.rs
@@ -2,8 +2,7 @@ use crate::file;
 use crate::otp;
 use data_encoding::BASE32_NOPAD;
 use std::path::PathBuf;
-
-const DELIMETER: &str = ":";
+use crate::models::Record;
 
 fn input_password() -> String {
     let password = rpassword::prompt_password("Enter password: ").expect("Failed to read password");
@@ -17,18 +16,18 @@ fn get_effective_password(password: &Option<String>) -> String {
         .unwrap_or_else(input_password)
 }
 
-fn get(unenc: &bool, unencrypt_curr: &str, pass: &String, x: &str) -> String {
-    let code = if unencrypt_curr == "0" {
-        otp::crypt(false, &x.to_string(), &pass)
+fn get(unenc: &bool, record: &Record, pass: &String) -> String {
+    let code = if !record.is_unencrypted {
+        otp::crypt(false, &record.secret, pass)
     } else {
-        x.to_string()
+        record.secret.clone()
     };
-    let otp = if *unenc && unencrypt_curr == "0" {
+
+    if *unenc && !record.is_unencrypted {
         "Cannot decrypt - provide a password".to_string()
     } else {
         otp::generate_otp(code.as_str())
-    };
-    otp
+    }
 }
 
 pub fn add(
@@ -39,17 +38,16 @@ pub fn add(
     password: &Option<String>,
 ) {
     // make code uppercase to solve the bug #1
-    let binding = code.to_uppercase();
-    let code = binding.as_str();
+    let binding = code.to_uppercase().replace("=", "");
+    let clean_code = binding.as_str();
 
     // create a storage file if it does not exist
-    let code_encrypted = if *unencrypt {
-        code.to_string()
+    let secret = if *unencrypt {
+        clean_code.to_string()
     } else {
         let pass = get_effective_password(password);
-        otp::crypt(true, &code.to_string(), &pass)
+        otp::crypt(true, &clean_code.to_string(), &pass)
     };
-    let is_unencrypted = *unencrypt as u8;
 
     /* Validate code - check if it is a valid base32
      * Here I beleive it is necessary to add some explanation for base32 and TOTP.
@@ -80,31 +78,26 @@ pub fn add(
      * data-encoding - different results.
      * I stick for now with data-encoding only because it more popular.
      */
-    match BASE32_NOPAD.decode(code.as_bytes()) {
-        Ok(_) => (),
-        Err(e) => {
-            println!("Error data-encoding BASE32: {e}");
-            std::process::exit(1);
-        }
+    if let Err(e) = BASE32_NOPAD.decode(clean_code.as_bytes()) {
+        eprintln!("Error data-encoding BASE32: {e}");
+        std::process::exit(1);
     }
 
-    // sha for the future use
-    let sha = "sha1";
-    let data = format!("{}:{}:{}:{}\n", alias, code_encrypted, is_unencrypted, sha);
+    // create Record Obj
+    let record = Record::new(alias.to_string(), secret.to_string(), *unencrypt);
+    let json_data = serde_json::to_string(&record).expect("Failed to serialize record");
 
     if file::file_exists(codex_path) {
-        // check if alias already exists and return error message
-        if file::alias_exists(&alias, &codex_path) == true {
+        if file::alias_exists(alias, codex_path) {
             eprintln!("Alias already exists, please select another one");
             std::process::exit(1);
         }
-        file::write(codex_path, &data);
+        file::write(codex_path, &json_data).expect("Failed to append record");
     } else {
-        if file::create_path(codex_path) {
-            let msg = "Record saved to codex";
-            file::write_to_file(codex_path, &data, &msg);
-        }
+        file::create_path(codex_path).expect("Failed to create path");
+        file::write_to_file(codex_path, &json_data, "Record saved to codex").expect("Failed to save codex");
     }
+    
     let otp = otp::generate_otp(code);
     println!("{otp}");
 }
@@ -144,53 +137,62 @@ pub fn update_code(
 }
 
 pub fn remove(path: &PathBuf, alias: &str) -> bool {
-    let lines = file::read_file_to_vec(&path);
-    let mut data = "".to_owned();
-    let mut f: bool = false;
+    let lines = file::read_file_to_vec(&path).unwrap_or_default();
+    let mut new_lines: Vec<String> = Vec::new();
+    let mut found: bool = false;
+
     for l in lines {
-        let x: Vec<&str> = l.split(DELIMETER).collect();
-        if x[0] != alias {
-            data = data + &l + "\n";
-        } else {
-            f = true;
+        // hybrid parser from Record struct
+        if let Some(record) = Record::from_line(&l) {
+            if record.alias == alias {
+                found = true;
+                continue; // Skip this one
+            }
         }
+        new_lines.push(l);
     }
-    if f {
-        let msg = format!("Record for {alias} has been removed from codex");
-        file::write_to_file(path, &data, &msg);
+
+    if found {
+        let data = new_lines.join("\n") + "\n";
+        file::write_to_file(path, &data, "Record removed").expect("Failed to update codex");
+        println!("Record for {alias} removed.");
     }
-    f
+    found
 }
 
 pub fn ls(
     codex_path: &PathBuf,
-    alias: &Option<String>,
+    alias_filter: &Option<String>,
     unencrypt: &bool,
     password: &Option<String>,
 ) {
-    let lines = file::read_file_to_vec(&codex_path);
-    let pass: String = if *unencrypt {
-        "".to_string()
-    } else {
-        get_effective_password(password)
-    };
-    if alias.is_none() {
+    let lines = file::read_file_to_vec(codex_path).unwrap_or_else(|_| {
+        eprintln!("Codex not found.");
+        std::process::exit(1);
+    });
+
+    let pass = if *unencrypt { String::new() } else { get_effective_password(password) };
+
+    if alias_filter.is_none() {
         println!("{0: <15} | {1: <15}", "Alias", "OTP");
     }
+
     for l in lines {
-        let x: Vec<&str> = l.split(DELIMETER).collect();
-        let alias_curr = x[0];
-        let unencrypt_curr = x[2];
-        if alias.is_some() {
-            if alias.as_ref().unwrap() == alias_curr {
-                let otp = get(&unencrypt, &unencrypt_curr, &pass, &x[1]);
-                println!("{otp}");
-                break;
+        if let Some(record) = Record::from_line(&l) {
+            let matches_filter = match alias_filter {
+                Some(f) => f == &record.alias,
+                None => true,
+            };
+
+            if matches_filter {
+                let otp = get(unencrypt, &record, &pass);
+                if alias_filter.is_some() {
+                    println!("{otp}");
+                    return;
+                } else {
+                    println!("{0: <15} | {1: <15}", record.alias, otp);
+                }
             }
-        } else {
-            let otp = get(&unencrypt, &unencrypt_curr, &pass, &x[1]);
-            println!("{0: <15} | {1: <15}", alias_curr, otp);
         }
     }
-    std::process::exit(0);
 }
diff --git a/src/file.rs b/src/file.rs
index 5e4569f..4947932 100644
--- a/src/file.rs
+++ b/src/file.rs
@@ -1,6 +1,6 @@
 use dirs;
 use std::fs::{File, OpenOptions};
-use std::io::{self, BufRead, BufReader, Write};
+use std::io::{self, BufRead, Write};
 use std::path::{Path, PathBuf};
 
 const FILE_CODEX: &str = "codex";
@@ -26,42 +26,27 @@ pub fn file_exists(path: &PathBuf) -> bool {
     Path::new(&path).exists()
 }
 
-pub fn read_file_to_vec(path: &PathBuf) -> Vec<String> {
-    if file_exists(path) {
-        let file = File::open(path).expect("There is no codex file");
-        let file = BufReader::new(file);
-        file.lines()
-            .map(|x| x.expect("Could not parse line"))
-            .collect()
-    } else {
-        println!(
-            "{FILE_CODEX} file does not exist.\n\
-            Please use hermes add command\n\
-            or copy existing {FILE_CODEX} to a default location"
-        );
-        std::process::exit(1);
-    }
+pub fn read_file_to_vec(path: &PathBuf) -> io::Result<Vec<String>> {
+    read_lines(path).map_err(|_| {
+        io::Error::new(
+            io::ErrorKind::NotFound,
+            format!("Codex file not found at {:?}. Use 'add' to create it.", path)
+        )
+    })?
+    .collect()
 }
 
-pub fn write(path: &PathBuf, data: &str) {
+pub fn write(path: &PathBuf, data: &str) -> io::Result<()> {
     let mut data_file = OpenOptions::new()
         .append(true)
-        .open(path)
-        .expect("Cannot open file");
-    data_file
-        .write(data.as_bytes())
-        .expect("Failed to write codex file");
+        .open(path)?;
+    writeln!(data_file, "{}", data.trim())
 }
 
-pub fn write_to_file(path: &PathBuf, data: &str, msg: &str) {
-    match std::fs::write(path, data) {
-        Ok(_) => {
-            println!("{msg}");
-        }
-        Err(e) => {
-            eprintln!("Failed to save codex. Error: {e}");
-        }
-    }
+pub fn write_to_file(path: &PathBuf, data: &str, msg: &str) -> io::Result<()> {
+    std::fs::write(path, data)?;
+    println!("{msg}");
+    Ok(())
 }
 
 pub fn alias_exists(alias: &str, codex_path: &PathBuf) -> bool {
@@ -79,11 +64,8 @@ pub fn alias_exists(alias: &str, codex_path: &PathBuf) -> bool {
     false
 }
 
-pub fn create_path(path: &PathBuf) -> bool {
-    let mut p: PathBuf = path.to_path_buf();
+pub fn create_path(path: &PathBuf) -> io::Result<()> {
+    let mut p = path.clone();
     p.pop();
-    match std::fs::create_dir_all(&p) {
-        Ok(_) => true,
-        Err(_e) => false,
-    }
+    std::fs::create_dir_all(p)
 }
diff --git a/src/main.rs b/src/main.rs
index fbbf86d..4fbaba9 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,6 +2,7 @@ use clap::{Parser, Subcommand};
 use std::path::PathBuf;
 
 mod cmd;
+mod models;
 mod file;
 mod otp;
 
diff --git a/src/models.rs b/src/models.rs
index b717641..05f0833 100644
--- a/src/models.rs
+++ b/src/models.rs
@@ -1,8 +1,6 @@
 use serde::{Deserialize, Serialize};
 use std::time::{SystemTime, UNIX_EPOCH};
 
-const DELIMETER: &str = ":";
-
 #[derive(Serialize, Deserialize, Debug, Clone)]
 pub struct Record {
     pub alias: String,
@@ -28,4 +26,30 @@ impl Record {
             created_at: since_the_epoch,
         }
     }
+
+    /// Attempts to parse line into a Record, supports both JSON and Legacy (text)
+    pub fn from_line(line: &str) -> Option<Self> {
+        let trimmed = line.trim();
+        if trimmed.is_empty() {
+            return None;
+        }
+
+        // try JSON first
+        if let Ok(record) = serde_json::from_str::<Record>(trimmed) {
+            return Some(record);
+        }
+
+        // fallback to Legacy (text), divider is colon
+        let parts: Vec<&str> = trimmed.split(':').collect();
+        if parts.len() >= 4 {
+            return Some(Record {
+                alias: parts[0].to_string(),
+                secret: parts[1].to_string(),
+                is_unencrypted: parts[2] == "1",
+                algorithm: parts[3].to_string(),
+                created_at: 0,
+            });
+        }
+        None
+    }
 }
